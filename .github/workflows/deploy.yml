name: Deploy NixOS Configuration

on:
  push:
    branches:
      - main # Or your default branch
  workflow_dispatch: # Allows manual triggering

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      # packages: write # Only if you plan to use GitHub Packages as a Nix cache
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          nix_path: nixpkgs=channel:nixos-24.11 # Or your desired Nixpkgs channel
          # extra_nix_config: | # Optional: if you use a binary cache
          #   substituters = https://cache.nixos.org/ https://your-cachix-name.cachix.org
          #   trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= your-cachix-name.cachix.org-1:your-key

      - name: Setup Tailscale
        uses: tailscale/github-action@v3
        with:
          authkey: ${{ secrets.TS_AUTHKEY }}
          args: --accept-risk=lose-ssh-host-keys
          # version: 1.32.0 # Optional: pin Tailscale version

      - name: Get Tailscale IPs
        run: |
          echo "Waiting for Tailscale to initialize..."
          sleep 5
          tailscale status
          # Extract the actual IP addresses for direct connections
          echo "CORE1_IP=$(tailscale status | grep core1 | awk '{print $1}')" >> $GITHUB_ENV
          echo "CORE2_IP=$(tailscale status | grep core2 | awk '{print $1}')" >> $GITHUB_ENV
          echo "CORE3_IP=$(tailscale status | grep core3 | awk '{print $1}')" >> $GITHUB_ENV
          echo "CORE4_IP=$(tailscale status | grep core4 | awk '{print $1}')" >> $GITHUB_ENV

      - name: Configure SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY_FOR_COLMENA }}
        run: |
          mkdir -p ~/.ssh
          echo "${SSH_PRIVATE_KEY}" > ~/.ssh/id_colmena
          chmod 600 ~/.ssh/id_colmena

          # Extract IPs from tailscale status directly
          CORE1_IP=$(tailscale status | grep core1 | awk '{print $1}')
          CORE2_IP=$(tailscale status | grep core2 | awk '{print $1}')
          CORE3_IP=$(tailscale status | grep core3 | awk '{print $1}')
          CORE4_IP=$(tailscale status | grep core4 | awk '{print $1}')

          # Create a custom SSH wrapper script to use for Tailscale connections
          # This bypasses the Tailscale SSH and directly uses TCP via tailscale netcat
          cat <<EOF > ~/tailscale-ssh.sh
          #!/bin/bash
          HOST=\$1
          shift

          # Extract the IP from our mapping
          if [[ "\$HOST" == "core1" ]]; then
            IP=$CORE1_IP
          elif [[ "\$HOST" == "core2" ]]; then
            IP=$CORE2_IP
          elif [[ "\$HOST" == "core3" ]]; then
            IP=$CORE3_IP
          elif [[ "\$HOST" == "core4" ]]; then
            IP=$CORE4_IP
          else
            IP=\$HOST
          fi

          # Connect using regular SSH but with netcat for the connection
          ssh -i ~/.ssh/id_colmena -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ProxyCommand="tailscale netcat \$IP 22" root@\$IP "\$@"
          EOF

          chmod +x ~/tailscale-ssh.sh

          # Create SSH config with direct IP connections via netcat
          cat <<EOF > ~/.ssh/config
          Host core1 core2 core3 core4
            User root
            IdentityFile ~/.ssh/id_colmena
            StrictHostKeyChecking no
            UserKnownHostsFile /dev/null
            PreferredAuthentications publickey
            PubkeyAcceptedKeyTypes +ssh-rsa
            ProxyCommand tailscale netcat %h 22
          EOF
          chmod 600 ~/.ssh/config

          # Print SSH key fingerprint for debugging
          ssh-keygen -l -f ~/.ssh/id_colmena || echo "Invalid key format"

      - name: Import SOPS Age Key
        env:
          SOPS_AGE_KEY: ${{ secrets.SOPS_AGE_KEY }}
        run: |
          mkdir -p ~/.config/sops/age
          echo "${SOPS_AGE_KEY}" > ~/.config/sops/age/keys.txt
          chmod 600 ~/.config/sops/age/keys.txt
          # sops --decrypt secrets/k3s-agent-node-token # Test decryption (optional)

      - name: Deploy NixOS Configuration to Nodes
        run: |
          echo "Attempting to connect to Tailscale nodes..."
          for i in {1..10}; do
            if tailscale status | grep -q "core1"; then # Check one of your nodes
              echo "Tailscale connection established."
              break
            fi
            echo "Waiting for Tailscale to connect... attempt $i"
            sleep 5
          done
          tailscale status # Display Tailscale status for debugging

          # Test connections with our custom wrapper script
          echo "Testing SSH connections with custom wrapper..."
          for node in core1 core2 core3 core4; do
            echo "Testing connection to $node..."
            # Try our custom wrapper
            ~/tailscale-ssh.sh $node "echo Custom SSH to $node successful" || echo "Custom connection failed"
          done

          # Ensure the flake inputs are up-to-date
          nix flake lock --update-input nixpkgs

          # Deploy to each node
          NODES="core1 core2 core3 core4"
          for node in $NODES; do
            echo "Deploying to $node..."
            
            # Build locally first to avoid SSH issues during the build phase
            echo "Building system for $node locally..."
            nix build .#nixosConfigurations.$node.config.system.build.toplevel --show-trace
            
            # Get the closure path
            CLOSURE_PATH=$(readlink -f result)
            echo "Built system closure at $CLOSURE_PATH"
            
            # Copy to remote and activate using our custom script
            echo "Copying to $node and activating..."
            nix copy --to ssh://root@$node?remote-store=local?root=/nix/store $CLOSURE_PATH || \
              nix copy --to "ssh-ng://root@$node" $CLOSURE_PATH
            
            # Activate the configuration
            ~/tailscale-ssh.sh $node "$CLOSURE_PATH/bin/switch-to-configuration switch"
            
            echo "Deployment to $node completed."
          done
          echo "All nodes deployed."
